---
layout: post
title: "Variable"
date: 2020-01-21 22:00:00 +0900
categories: Java
---

---
## ▶ Variable
단 하나의 값을 저장할 수 있는 메모리상의 공간이다. 단 하나의 값만 저장할 수 있으므로 새로운 값을 저장할 경우 기존의 값은 사라지게 된다.

---
### 1. 변수의 선언 및 초기화
변수를 사용하려면 먼저 변수를 선언해야 한다.

#### 1. 변수의 선언
~~~ java
public static void main(String[] args) {
    int var = 25; // int는 변수타입, var은 변수명, 25의 대입을 통해 변수를 초기화
}
~~~

변수타입을 통해 저장될 값이 어떤 타입인지 지정하면 메모리의 빈 공간에 알맞은 크기의 저장공간이 확보된다. 이 저장공간은 변수이름을 통해 사용할 수 있다. 변수명은 서로 구별되어야 하기 때문에 같은 이름의 변수가 여러 개 존재해서는 안 된다.

#### 2. 변수의 초기화
변수를 선언한 이후부터는 그 변수를 사용할 수 있으나, 그 전에 반드시 변수를 초기화 할 필요가 있다. 메모리는 여러 프로그램이 공유하는 자원이므로 다른 프로그램에 의해 저장된 Garbage Value가 남아 있을 수 있기 때문이다.

#### 3. 변수의 명명규칙
###### 1. 대소문자가 구분되며, 길이에 제한이 없다.
###### 2. 예약어를 사용해서는 안된다.
예약어(Reserved word)는 컴퓨터 프로그래밍 언어에서 문법적인 용도로 사용하는 단어를 총칭한다.
###### 3. 숫자로 시작해서는 안 된다.
###### 4. 특수문자는 '_', '$'만을 허용한다.

---
### 2. 데이터 저장 방식에 따른 분류
자바에서 변수는 데이터의 저장 방식에 따라 기본형 타입(Primitive type)과 참조형 타입(Reference type)으로 분류된다. 기본형 타입의 변수는 실제 값을 저장하는 반면, 참조형 타입의 변수는 어떤 값이 저장되어 있는 주소를 값으로 갖는다.

![dataTypes](https://user-images.githubusercontent.com/51690528/102716938-66592780-4322-11eb-8ae5-f0757ef73b23.jpg)

<br>
#### 1. 기본형 타입 변수
기본형에는 모두 8개의 타입이 존재한다.

| 분류 | 타입 | 크기 | 저장 가능한 값의 범위 | 기본값 | 정밀도 |
|:---:|:-:|:-:|:-------:|:-------:|:-------:|
| 논리형 | boolean | 1byte | false, true | false | |
| 문자형 | char | 2byte | 0 ~ 2<sup>16</sup>-1 | '\u0000'  | |
| 정수형 | byte | 1byte | -2<sup>7</sup> ~ 2<sup>7</sup>-1| 0 | |
|     | short | 2byte | -2<sup>15</sup> ~ 2<sup>15</sup>-1 | 0 | |
|     | int | 4byte | -2<sup>31</sup> ~ 2<sup>31</sup>-1 | 0 | |
|     | long | 8byte | -2<sup>63</sup> ~ 2<sup>63</sup>-1 | 0L | |
| 실수형 | float | 4byte | 1.4 * 10<sup>-45</sup> ~ 3.4 * 10<sup>38</sup> | 0.0f | 7자리 |
|     | double | 8byte | 4.9 * 10<sup>-324</sup> ~ 1.8 * 10<sup>308</sup> | 0.0 | 15자리 |

#### 2. 기본형의 표현범위
저장공간이 표현 가능한 값의 개수에 영향을 받는다. 예를 들어 byte 타입은 8bit의 조합이므로 2<sup>8</sup> = 256개의 데이터를 표현할 수 있다.

##### 1. 논리형
논리형 자료형에는 boolean이 존재한다.
boolean형 변수는 true 또는 false를 저장할 수 있으며, 기본값은 false이다. 2개의 값만 표현하면 되므로 1bit로 충분하지만 자바에서 데이터를 다루는 최소 단위가 byte이기 때문에, 크기가 1byte로 책정되었다.

##### 2. 문자형
문자형 자료형에는 char이 존재한다. 자바에서는 문자의 표현을 위한 인코딩으로 유니코드를 사용한다.

###### ▶ 유니코드
유니코드는 모든 문자를 2byte로 표현하려 했으나, 부족해서 21bit로 확장되었다. 새로 추가된 보충문자를 사용하기 위해서는 int타입을 사용해야 한다. 유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 등 여러가지 종류가 있는데 자바에서는 UTF-16을 사용한다. UTF-16은 모든 문자를 2byte의 고정크기로 표현한다.

##### 3. 정수형
정수형 자료형에는 byte, short, int, long이 존재한다. 정수형은 다음과 같은 형식으로 저장된다.

![IntegerType](https://user-images.githubusercontent.com/51690528/102720853-2bfb8480-433a-11eb-8341-a3d83afda203.png)

2의 보수(two's complement)를 통한 숫자 표현시 제일 상위(왼쪽, MSB-Most Significant Bit) 비트를 부호(sign) 처리용으로 할당한다. 저장 공간의 첫 비트를 부호 표현으로 사용하기 때문에 정수형의 포현범위는 -2<sup>n-1</sup> ~ 2<sup>n-1</sup>-1가 된다.

###### ▶ 2의 보수
컴퓨터에서 숫자를 표현하는 방법 중 하나이다. 음수를 표현할 때, 양수의 모든 비트를 반전 (0은 1로 1은 0으로) 시킨 후 그 결과에 1을 더한 숫자로 표현한다. 음수를 더하는 방식으로 뺄셈을 할 수 있으며, sign bit를 부호로 표현시 0이 두개나 존재하는 모순이 해결된다는 장점이 존재한다.

###### ▶ 정수형의 선택기준
정수형을 선택할 때 되도록 int를 사용하는 것이 좋다. JVM의 operand stack이 피연산자를 4byte 단위로 저장하기 때문이다. byte나 short형이 메모리를 조금 더 절약할 수 있으나, 4byte보다 작은 자료형을 계산할 때 결국 4byte인 int형으로 변환하여 연산을 수행하기 때문에 성능상 int를 사용하는 것이 더 효율적이다.

###### ▶ Unsigned int
자바에선 unsigned 키워드를 지원하지 않는다. 따라서, 부호없는 정수를 지원하지 않는다. 이로 인해 unsigned로 인한 오류가 발생하지 않게 된다는 장점과 unsigned를 지원하는 다른 언어와 통신하다 발생하는 unsigned 변환 문제를 해결해야 한다는 단점을 가지게 되었다.

##### 3. 실수형
실수형 자료형에는 float, double이 존재한다. 실수형은 다음과 같은 형식으로 저장된다.

- Float Type
![IEEE-754-FloatType](https://user-images.githubusercontent.com/51690528/102720949-ca87e580-433a-11eb-9762-36572b7c0aed.jpg)

- Double Type
![IEEE-754-DoubleType](https://user-images.githubusercontent.com/51690528/102720948-c9ef4f00-433a-11eb-9273-d838625166b9.jpg)

출처 : <a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">IEEE Standard 754 Floating Point Numbers</a>

정수형과 다르게 표현을 위한 저장공간이 부호(Sign), 지수(Exponent), 가수(Mantissa)의 세 가지로 구분되며, 가수 * 2<sup>(지수 - 바이어스(bias, 127))</sup>로 값을 구할 수 있다. 이 표현형식은 IEEE754 표준을 따르고 있다.

###### ▶ 부동소수점의 오차
2진수로는 10진소수를 정확하기 어렵기 때문에, 저장 과정에서 값의 손실이 있을 수 있다. 가수가 23bit인 float는 2<sup>-23</sup> → 10진수로 7자리, 가수가 52bit인 double은 2<sup>-52</sup> → 10진수로 15자리가 된다. 이하의 값은 잘려나가기 때문이다. 오차 없는 값을 얻기 위해서는 BigDecimal 클래스를 이용해야 한다.

#### 3. 참조형 타입 변수
어떤 값이 저장되어 있는 주소를 값으로 가지며, 주소값을 통해 그 값을 참조하는 변수이다. 그 종류에는 class, interface, array가 있다. enum은 크게 클래스의 범주에 포함되며, annotation은 interface의 범주에 포함된다.

#### 4. 기본형 타입과 참조형 타입의 비교
기본형 타입의 비교는 실제값을 비교한다. 하지만 참조형 타입을 비교할 경우 그 실제 값이 아닌 주소값을 비교하기 때문에 실제 값이 같더라도 가리키고 있는 주소값이 다를 경우 비교의 결과로 false를 반환한다. 그래서 참조형 타입의 실제 값을 비교하기 위해서는 Object.equals() 메서드를 재정의할 필요가 있다.

---
### 3. 선언 위치에 따른 분류
변수는 선언 위치에 따라 클래스변수, 인스턴스변수, 지역변수의 세 가지로 구분된다.

~~~ java
public class Test {
    // 클래스변수
    static int classVar;

    // 인스턴스변수
    int instanceVar;

    public static void main(String[] args) {
        // 지역변수        
        int localVar;
    }
}
~~~

#### 1. 인스턴스변수
클래스 영역에서 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 인스턴스는 서로 독립적인 저장공간을 가지므로, 다른 인스턴스와 다른 값을 가질 수 있다.

#### 2. 클래스변수
클래스 영역에서 선언되며, 앞에 static 키워드를 추가해 줄 경우 클래스변수가 된다. 클래스변수는 모든 인스턴스가 공통된 저장공간을 공유하며 클래스가 메모리에 적재될 때 생성된다.

#### 3. 지역변수
블럭 내에서 선언되어 그 블럭 내에서만 사용 가능한 메서드를 지역변수라고 한다.

---
### 4. 리터럴
리터럴은 변수나 상수에 저장되는 값 그 자체를 의미한다. 정수, 실수, 문자, 문자열, boolean 리터럴이 존재한다.

~~~ java
int i = 1_000_000; // 정수형 리터럴, JDK 1.7부터 구분자를 넣는 것이 가능하다.
int i2 = 0b10000; // 이진수 리터럴
int i3 = 0x10000; // 16진수 리터럴
long l = 1.0; // 실수형 리터럴
char c = 'c'; // 문자형 리터럴
String s = "String"; // 문자열 리터럴
boolean b = true; // 불린 리터럴
~~~

---
### 5. 캐스팅
변수 또는 상수의 타입을 다른 타입으로 변환하는 것을 말한다. 피연산자의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주면 된다.

~~~
(타입) 피연산자
~~~

#### 1. 기본형 타입의 캐스팅
기본형 타입의 형변환은 값손실의 위험이 없을 경우, 캐스팅을 명시하지 않아도 컴파일러가 생략된 형변환을 자동으로 추가해준다. 이를 프로모션이라고 한다. 반대의 경우는 반드시 명시적인 캐스팅이 필요하다.

##### ▶ 자동 형변환이 가능한 경우
1. byte → short, int, long, float, double
2. short → int, long, float, double
3. char → int, long, float, double
4. int → long, float, double
5. long → float, double
6. float → double

#### 2. 참조형 타입의 캐스팅
조상타입, 자손타입 간의 형변환이 가능하다. 이 때의 형변환 역시 변환하고자 하는 타입을 괄호와 함께 붙여주면 된다.

##### ▶ Upcasting
자손타입의 객체를 조상타입으로 형변환 하는 것을 말한다. 이 경우에는 형변환의 생략이 가능하다.

##### ▶ Downcasting
조상타입의 객체를 자손타입으로 변환하는 것을 말한다. 이 경우에는 형변환의 생략이 불가능하다. 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있
는 멤버의 개수보다 많을 수 있기 때문이다.

---
### ▶ Reference
- 남궁성, 『자바의 정석』, 도우출판
- <a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">IEEE Standard 754 Floating Point Numbers</a>
- <a href="http://nlp.kookmin.ac.kr/sskang/JOC/Chapters/cprog/basic.htm">컴퓨터의 수 처리 체계</a>
